# 2. PARSING

---

## 2.1. Parsers

we may heard of "parser error" or:

- we need to parse this
- after it's parsed
- the parser blows up with this input

the word "parser", as common as, compiler, interpreter, and programming language.

what's parser, according to wikipedia:

- a parser is a software component
- that takes input data (frequently text)
- and builds a data structure (often "parse tree", AST, or other hierarchical structure)
- giving a structural representational of the input
- checking for correct syntax in the process
- often preceded by a separate lexical analyser
  - lexical analyser: creates tokens form the sequence of input characters
  
A parser:

- turns input into a data structure that represents the input
- example in JavaScript

```js
> var input = '{"name": "Mark", "age": 10}';
> var output = JSON.parse(input);
output
{ name: 'Mark', age: 10 }
> output.name
'Mark'
> output.age
10
>
```

- `input` is just some text, a string (in JSON format)
- we pass the `input` to a parser, underlying `JSON.parse` function
- `output` is the data structure that represents the `input`
  - input as a JavaScript object with two fields named `name` and `age`

but we often hear:
 
> "a JSON parser is not the same as a parser for a programming language!, they are differnet!"

actually no, they are NOT different (at least not on a conceptual level)

a JSON parser:

- takes text as input
- builds a data structure that represents the input

this is exactly what parsers of programming languages do. 

The differences?

- for JSON, you can see the data structure when looking at the `input`
- whereas in normal programming language's case:
  - `if ((5 + 2 * 3) == 91) { return computeStuff(input1, input2); }`
  - not immediately can see how it would be represented with a data structure 

additionally:

> "As users of programming languages we seldom get to see or
   interact with the parsed source code, with its internal representation. Lisp programmers are
   the exception to the rule – in Lisp the data structures used to represent the source code are the
   ones used by a Lisp user. The parsed source code is easily accessible as data in the program.
   “Code is data, data is code” is something you hear a lot from Lisp programmers."

- to bring our conceptual understanding of programming language parsers
  - up to the level of our familiarity, intuitiveness with parcers of serialisation languages
  - e.g. `JSON`, `YAML`, `TOML`, `INI`, ...
- we need to understand
  - the data structures parsers produce
  
most interpreters / compilers, the data structure used as the internal representation of the source code:

- syntax tree
- abstract syntax tree a.k.a. AST

```gopher
if (3 * 5 > 10) {
    return "hello";
} else {
    return "goodbye";
}
```

assume:

- we use JavaScript
- have a `MagicLexer`, `MagicParser`
- the AST is built out of JavaScript objects
- the parsing step might produce something like this:

```js
> var input = 'if (3 * 5 > 10) { return "hello"; } else { return "goodbye"; }';
> var tokens = MagicLexer.parse(input);
> MagicParser.parse(tokens);
{
    type: "if-statement",
    condition: {
        type: "operator-expression",
        operator: ">",
        left: {
            type: "operator-expression",
            operator: "*",
            left: { type: "integer-literal", value: 3 },
            right: { type: "integer-literal", value: 5 }
        },
        right: { type: "integer-literal", value: 10 }
    },
    consequence: {
        type: "return-statement",
        returnValue: { type: "string-literal", value: "hello" }
    },
    alternative: {
        type: "return-statement",
        returnValue: { type: "string-literal", value: "goodbye" }
    }
}
```

the AST (the output of the parser), is pretty abstract:

- no parentheses
- no semicolons
- no braces

BUT, it does represent the source code quite accurately.

in short, parsers:

- take source code as input - text or token
- produce a data structure that represents the given source code
- whilst building up the data structure,
  - analyse the input
  - checking that it conforms to the expected structure
  - this process os parsing called "syntactic analysis"


---
